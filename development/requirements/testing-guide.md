# Testing Guide

This document outlines best practices and methodologies for testing Makefiles in the Bowerbird project.

## Core Principles

### One Test File Per Macro

**Each test file should focus on testing a single macro or closely related group of macros.**

This makes tests easier to find, maintain, and reason about.

**Good - One macro per file:**
```makefile
# test-compare-strings.mk - Tests ONLY compare-strings
test-compare-strings-equal: ...
test-compare-strings-not-equal: ...
test-compare-strings-error-message: ...

# test-compare-sets.mk - Tests ONLY compare-sets
test-compare-sets-equal: ...
test-compare-sets-not-equal: ...
test-compare-sets-error-message: ...
```

**Bad - Multiple macros in one file:**
```makefile
# test-compare-errors.mk - Tests error messages for ALL compare macros
test-compare-strings-error-message: ...
test-compare-sets-error-message: ...
test-compare-files-error-message: ...
test-compare-file-content-error-message: ...
```

**Rationale:**
- Easier to locate tests for a specific macro
- Clear 1:1 relationship between source files and test files
- Tests stay co-located with what they're testing
- Easier to ensure complete coverage of a single macro
- Simpler to refactor or remove functionality

**Pattern:**
| Source File | Primary Macro | Test File |
|------------|---------------|-----------|
| `bowerbird-compare.mk` | `bowerbird::test::compare-strings` | `test-compare-strings.mk` |
| `bowerbird-compare.mk` | `bowerbird::test::compare-sets` | `test-compare-sets.mk` |
| `bowerbird-compare.mk` | `bowerbird::test::compare-files` | `test-compare-files.mk` |

### Test Target Naming

Test targets should have descriptive names that explain what they test. **No docstrings needed for test targets:**

```makefile
# Good - descriptive name
test-compare-strings-equal:
	$(call bowerbird::test::compare-strings,alpha,alpha)


# Bad - vague name requiring docstring
test-strings:
	$(call bowerbird::test::compare-strings,alpha,alpha)
```

## Error Message Testing

**CRITICAL: All error messages and warnings MUST be tested.**

Error messages are part of the user-facing API. They must be:
1. Tested for correct content
2. Verified to go to stderr (not stdout)
3. Checked for consistent formatting (e.g., "ERROR:" prefix)

### Shell-Generated Errors (Easy to Test)

When errors are generated in shell commands (recipe lines), they can be captured directly:

```makefile
# Macro that generates shell error
define bowerbird::test::compare-strings # str1, str2
    test "$1" = "$2" || \
            (echo "ERROR: Failed string comparison: '$1' != '$2'" >&2 && exit 1)
endef

# Test the error message
test-compare-strings-error-message:
	@output=$$($(call bowerbird::test::compare-strings,actual,expected) 2>&1 || true); \
		echo "$$output" | grep -q "ERROR: Failed string comparison: 'actual' != 'expected'"

# Test that error goes to stderr
test-compare-strings-error-to-stderr:
	@output=$$($(call bowerbird::test::compare-strings,foo,bar) 2>&1 || true); \
		test -n "$$output"

# Test error prefix consistency
test-compare-strings-error-has-prefix:
	@output=$$($(call bowerbird::test::compare-strings,a,b) 2>&1 || true); \
		echo "$$output" | grep -q "^ERROR:"
```

**Key technique**: Use `2>&1 || true` to:
- Capture both stdout and stderr (`2>&1`)
- Prevent test failure when the macro fails (expected behavior) (`|| true`)
- Store output in a variable for inspection

### Make-Generated Errors (Requires Recursive Make)

When errors are generated by Make itself (e.g., `$(error ...)` or validation in `$(if ...)`), you need recursive make to test them:

```makefile
# Macro with Make-generated error
define bowerbird::test::suite # target, path
$(if $1,,$(error ERROR: missing target in 'bowerbird::test::suite'))
$(if $2,,$(error ERROR: missing path in 'bowerbird::test::suite'))
# ... rest of implementation
endef

# Test Make-generated errors with recursive make
test-suite-error-missing-target:
	@output=$$($(MAKE) -f - test 2>&1 <<< \
		'include src/bowerbird-test/bowerbird-suite.mk\n\
		test:\n\
		\t$$(call bowerbird::test::suite,,/path)' || true); \
		echo "$$output" | grep -q "ERROR: missing target"

test-suite-error-missing-path:
	@output=$$($(MAKE) -f - test 2>&1 <<< \
		'include src/bowerbird-test/bowerbird-suite.mk\n\
		test:\n\
		\t$$(call bowerbird::test::suite,target,)' || true); \
		echo "$$output" | grep -q "ERROR: missing path"
```

**Why recursive make is needed**: Make evaluates `$(error ...)` during parse time before any recipes run. To capture this, you must invoke a new Make instance.

### Warning Message Testing

Warnings should also be tested to ensure they appear at the right times:

```makefile
# Test that warning appears when no files found
test-suite-warn-no-files:
	@mkdir -p $(WORKDIR_TEST)/$@/empty-dir
	@output=$$($(MAKE) -f - test 2>&1 <<< \
		'include src/bowerbird-test/bowerbird-suite.mk\n\
		WORKDIR_TEST=$(WORKDIR_TEST)/$@\n\
		$$(call bowerbird::test::suite,test-suite,$(WORKDIR_TEST)/$@/empty-dir)\n\
		test: test-suite' || true); \
		echo "$$output" | grep -q "WARNING: No test files found"
```

## Test Coverage Requirements

For each public macro, ensure tests cover:

### 1. Happy Path
- Normal operation with valid inputs
- Expected output or side effects

### 2. Edge Cases
- Empty inputs
- Single element vs. multiple elements
- Special characters
- Whitespace variations
- Very long inputs

### 3. Error Conditions
- Invalid inputs
- Missing files
- Type mismatches
- **Error message content** (REQUIRED)
- **Error message goes to stderr** (REQUIRED)
- **Error message format/prefix** (REQUIRED)

### 4. Corner Cases
- Boundary conditions
- Multiple permutations (for functions with lists)
- Order independence (where applicable)
- Duplicate handling

## Testing Patterns

### Pattern 1: Basic Assertion

```makefile
test-macro-basic:
	$(call my-macro,input) || exit 1
```

### Pattern 2: Negative Test

```makefile
test-macro-should-fail:
	! $(call my-macro,bad-input)
```

### Pattern 3: Output Comparison

```makefile
test-macro-output:
	@output=$$($(call my-macro,input)); \
		test "$$output" = "expected"
```

### Pattern 4: File Comparison

```makefile
test-macro-file-output:
	@mkdir -p $(WORKDIR_TEST)/$@
	$(call my-macro,input,$(WORKDIR_TEST)/$@/output.txt)
	$(call bowerbird::test::compare-file-content-from-var,\
		$(WORKDIR_TEST)/$@/output.txt,expected-variable)
```

### Pattern 5: Error Message Testing

```makefile
test-macro-error-message:
	@output=$$($(call my-macro,bad-input) 2>&1 || true); \
		echo "$$output" | grep -q "ERROR: expected error text"
```

### Pattern 6: State Verification

```makefile
test-macro-creates-files:
	@mkdir -p $(WORKDIR_TEST)/$@
	$(call my-macro,$(WORKDIR_TEST)/$@)
	test -f $(WORKDIR_TEST)/$@/expected-file.txt
```

## Anti-Patterns to Avoid

### ❌ Don't: Create cross-cutting test files

```makefile
# BAD: test-all-errors.mk - tests errors from many macros
test-compare-strings-error: ...
test-compare-sets-error: ...
test-find-files-error: ...
```

### ❌ Don't: Use vague test names

```makefile
# BAD: What does this test?
test-strings: ...
test-case-1: ...
test-foo: ...
```

### ❌ Don't: Skip error message testing

```makefile
# BAD: Tests that macro fails, but doesn't verify error message
test-macro-fails:
	! $(call my-macro,bad-input)
```

### ❌ Don't: Test multiple unrelated things in one target

```makefile
# BAD: Tests too many things
test-macro:
	$(call my-macro,input1)
	$(call my-macro,input2)
	$(call my-macro,input3)
	! $(call my-macro,bad-input)
```

### ❌ Don't: Use unnecessary setup

```makefile
# BAD: mkdir not needed for pure string comparison
test-compare-strings:
	@mkdir -p $(WORKDIR_TEST)/$@  # ← unnecessary!
	@output=$$($(call bowerbird::test::compare-strings,a,b) 2>&1 || true)
```

## Best Practices

### ✅ Do: Test error messages explicitly

```makefile
test-macro-error-specific:
	@output=$$($(call my-macro,bad) 2>&1 || true); \
		echo "$$output" | grep -q "ERROR: Invalid input: 'bad'"
```

### ✅ Do: Test both positive and negative cases

```makefile
test-macro-success:
	$(call my-macro,good-input)

test-macro-failure:
	! $(call my-macro,bad-input)
```

### ✅ Do: Test permutations for list-based functions

```makefile
# Test various combinations
test-find-files-one-path-one-pattern: ...
test-find-files-one-path-multiple-patterns: ...
test-find-files-multiple-paths-one-pattern: ...
test-find-files-multiple-paths-multiple-patterns: ...
```

### ✅ Do: Use descriptive variable names in tests

```makefile
define expected-output
line 1
line 2
endef

test-macro:
	$(call bowerbird::test::compare-file-content-from-var,\
		$(WORKDIR_TEST)/$@/results.txt,\
		expected-output)
```

### ✅ Do: Clean up only what you need

```makefile
# Only mkdir when you create files
test-with-files:
	@mkdir -p $(WORKDIR_TEST)/$@
	@echo "content" > $(WORKDIR_TEST)/$@/file.txt
	# ... test ...

# No mkdir for pure logic tests
test-without-files:
	@output=$$($(call my-macro) 2>&1 || true)
	# ... test ...
```

## Error Message Format Standards

All error messages should follow consistent formatting:

### Error Format

```
ERROR: <description>: '<context>'
```

Examples:
- `ERROR: Failed string comparison: 'actual' != 'expected'`
- `ERROR: Failed list comparison: 'a b' != 'c d'`
- `ERROR: Failed file comparison:`
- `ERROR: Content mismatch for <filepath>`
- `ERROR: missing target in 'bowerbird::test::suite'`

### Warning Format

```
WARNING: <description>
```

Examples:
- `WARNING: No test files found in '/path' matching 'test*.mk'`

### Required Tests for Each Error/Warning

1. **Message content**: Verify exact text (or key parts)
2. **Stderr output**: Ensure errors go to stderr, not stdout
3. **Prefix consistency**: Check for "ERROR:" or "WARNING:" prefix

```makefile
# All three tests for each error message
test-macro-error-message:
	@output=$$($(call my-macro,bad) 2>&1 || true); \
		echo "$$output" | grep -q "ERROR: expected message"

test-macro-error-to-stderr:
	@output=$$($(call my-macro,bad) 2>&1 || true); \
		test -n "$$output"

test-macro-error-has-prefix:
	@output=$$($(call my-macro,bad) 2>&1 || true); \
		echo "$$output" | grep -q "^ERROR:"
```

## Summary Checklist

When creating tests for a new macro:

- [ ] Create dedicated test file named `test-<macro-name>.mk`
- [ ] Test happy path with valid inputs
- [ ] Test edge cases (empty, single, multiple, special chars)
- [ ] Test error conditions
- [ ] **Test all error message content**
- [ ] **Test errors go to stderr**
- [ ] **Test error message prefixes**
- [ ] Test warnings (if applicable)
- [ ] Test permutations for list-based operations
- [ ] Use descriptive test target names
- [ ] Only create files when necessary
- [ ] Use `|| true` when capturing expected failures
